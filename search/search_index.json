{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Antibars Bot","text":""},{"location":"#overview","title":"Overview","text":"<p>A Telegram bot system with asynchronous and synchronous implementations that monitors Google Sheets for changes and provides various information services including weather data, news headlines, and daily quotes.</p>"},{"location":"#purpose","title":"Purpose","text":"<p>The project serves as a notification bot that tracks changes in spreadsheet data and delivers real-time updates to subscribed users via Telegram. It combines multiple data sources and APIs to provide an interactive information service with concurrent processing capabilities for efficient monitoring and messaging.</p>"},{"location":"lab4/","title":"Lab4","text":""},{"location":"lab4/#overview","title":"Overview","text":"<p>Lab4 is a Telegram bot module that implements both synchronous and asynchronous functionality for monitoring Google Sheets data changes and providing information services. The module features concurrent processing capabilities for efficient data retrieval and notification delivery, integrating multiple external APIs including Telegram Bot API, OpenWeatherMap, and web scraping services.</p>"},{"location":"lab4/#purpose","title":"Purpose","text":"<p>The module serves as a notification system that periodically scans configured Google Sheets spreadsheets for data modifications and sends real-time alerts to subscribed Telegram users. It provides additional utility functions including weather information retrieval, news headline fetching, and daily quote services. The system maintains subscription management through a database backend and supports both immediate and scheduled monitoring operations with concurrent processing for optimal performance.</p>"},{"location":"lab4/async_bot/","title":"Async Bot","text":""},{"location":"lab4/async_bot/#lab4.async_bot.get_headlines","title":"<code>get_headlines(session)</code>  <code>async</code>","text":"<p>Fetches multiple website titles concurrently using asynchronous HTTP requests.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>ClientSession</code> <p>The HTTP client session used for making requests.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A formatted string containing all retrieved headlines, each on a new line with bullet points.</p> Source code in <code>lab4/async_bot.py</code> <pre><code>async def get_headlines(session: aiohttp.ClientSession) -&gt; str:\n    \"\"\"\n    Fetches multiple website titles concurrently using asynchronous HTTP requests.\n\n    Args:\n        session (aiohttp.ClientSession): The HTTP client session used for making requests.\n\n    Returns:\n        str: A formatted string containing all retrieved headlines, each on a new line with bullet points.\n\n    Why: This method performs concurrent HTTP requests to improve efficiency when fetching data from multiple sources simultaneously, reducing overall waiting time compared to sequential requests.\n    \"\"\"\n    tasks = [_fetch_title(session, url) for url in HEADLINE_URLS]\n    # gather \u0437\u0430\u043f\u0443\u0441\u043a\u0430\u0435\u0442 \u0432\u0441\u0435 \u043a\u043e\u0440\u0443\u0442\u0438\u043d\u044b \u043e\u0434\u043d\u043e\u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e \u0438 \u0436\u0434\u0451\u0442 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043d\u0438\u044f \u0432\u0441\u0435\u0445\n    results: List[str] = await asyncio.gather(*tasks)\n\n    return \"Headlines:\\n\" + \"\\n\".join(f\"- {line}\" for line in results)\n</code></pre>"},{"location":"lab4/async_bot/#lab4.async_bot.get_updates","title":"<code>get_updates(session, offset=None, timeout=POLLING_TIMEOUT)</code>  <code>async</code>","text":"<p>\u0410\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u043e\u0442 Telegram Bot API \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0445 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u0439.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>ClientSession</code> <p>HTTP-\u0441\u0435\u0441\u0441\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430.</p> required <code>offset</code> <code>Optional[int]</code> <p>\u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f.  \u0415\u0441\u043b\u0438 \u0443\u043a\u0430\u0437\u0430\u043d, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0441 \u0431\u043e\u043b\u0435\u0435 \u0432\u044b\u0441\u043e\u043a\u0438\u043c ID.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>\u0422\u0430\u0439\u043c\u0430\u0443\u0442 \u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u043e\u043f\u0440\u043e\u0441\u0430 \u0432 \u0441\u0435\u043a\u0443\u043d\u0434\u0430\u0445. \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e POLLING_TIMEOUT.</p> <code>POLLING_TIMEOUT</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: \u041e\u0442\u0432\u0435\u0442 API \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 JSON \u0441 \u043a\u043b\u044e\u0447\u0430\u043c\u0438: - ok (bool): \u0421\u0442\u0430\u0442\u0443\u0441 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430 - result (list): \u0421\u043f\u0438\u0441\u043e\u043a \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0439</p> <p>\u041c\u0435\u0442\u043e\u0434 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u0442 \u043c\u0435\u0445\u0430\u043d\u0438\u0437\u043c \u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u043e\u043f\u0440\u043e\u0441\u0430 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043d\u043e\u0432\u044b\u0445 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u043e\u0442 Telegram, \u0447\u0442\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0431\u043e\u0442\u0443 \u0440\u0435\u0430\u0433\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043d\u0430 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0435 \u0437\u0430\u043f\u0440\u043e\u0441\u044b \u0432 \u0440\u0435\u0430\u043b\u044c\u043d\u043e\u043c \u0432\u0440\u0435\u043c\u0435\u043d\u0438. \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0441\u043c\u0435\u0449\u0435\u043d\u0438\u044f (offset) \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0430\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u043d\u043e\u0432\u044b\u0445 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0439, \u0438\u0437\u0431\u0435\u0433\u0430\u044f \u0434\u0443\u0431\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f. \u0422\u0430\u0439\u043c\u0430\u0443\u0442 \u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u043e\u0448\u0438\u0431\u043e\u043a \u0433\u0430\u0440\u0430\u043d\u0442\u0438\u0440\u0443\u044e\u0442 \u0441\u0442\u0430\u0431\u0438\u043b\u044c\u043d\u0443\u044e \u0440\u0430\u0431\u043e\u0442\u0443 \u043f\u0440\u0438 \u0441\u0435\u0442\u0435\u0432\u044b\u0445 \u0441\u0431\u043e\u044f\u0445 \u0438\u043b\u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u043d\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0441\u0442\u0438 API.</p> Source code in <code>lab4/async_bot.py</code> <pre><code>async def get_updates(session: aiohttp.ClientSession,\n                      offset: Optional[int] = None,\n                      timeout: int = POLLING_TIMEOUT) -&gt; Dict[str, Any]:\n    \"\"\"\n    \u0410\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u043e\u0442 Telegram Bot API \u0434\u043b\u044f \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0438 \u0432\u0445\u043e\u0434\u044f\u0449\u0438\u0445 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u0439.\n\n    Args:\n        session (aiohttp.ClientSession): HTTP-\u0441\u0435\u0441\u0441\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430.\n        offset (Optional[int]): \u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f. \n            \u0415\u0441\u043b\u0438 \u0443\u043a\u0430\u0437\u0430\u043d, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0442\u0441\u044f \u0442\u043e\u043b\u044c\u043a\u043e \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u044f \u0441 \u0431\u043e\u043b\u0435\u0435 \u0432\u044b\u0441\u043e\u043a\u0438\u043c ID.\n        timeout (int): \u0422\u0430\u0439\u043c\u0430\u0443\u0442 \u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u043e\u043f\u0440\u043e\u0441\u0430 \u0432 \u0441\u0435\u043a\u0443\u043d\u0434\u0430\u0445. \u041f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e POLLING_TIMEOUT.\n\n    Returns:\n        Dict[str, Any]: \u041e\u0442\u0432\u0435\u0442 API \u0432 \u0444\u043e\u0440\u043c\u0430\u0442\u0435 JSON \u0441 \u043a\u043b\u044e\u0447\u0430\u043c\u0438:\n            - ok (bool): \u0421\u0442\u0430\u0442\u0443\u0441 \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430\n            - result (list): \u0421\u043f\u0438\u0441\u043e\u043a \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u043d\u044b\u0445 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0439\n\n    Why:\n    \u041c\u0435\u0442\u043e\u0434 \u0440\u0435\u0430\u043b\u0438\u0437\u0443\u0435\u0442 \u043c\u0435\u0445\u0430\u043d\u0438\u0437\u043c \u0434\u043b\u0438\u043d\u043d\u043e\u0433\u043e \u043e\u043f\u0440\u043e\u0441\u0430 \u0434\u043b\u044f \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u044f \u043d\u043e\u0432\u044b\u0445 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0439 \u0438 \u0441\u043e\u0431\u044b\u0442\u0438\u0439 \u043e\u0442 Telegram,\n    \u0447\u0442\u043e \u043f\u043e\u0437\u0432\u043e\u043b\u044f\u0435\u0442 \u0431\u043e\u0442\u0443 \u0440\u0435\u0430\u0433\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043d\u0430 \u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u0441\u043a\u0438\u0435 \u0437\u0430\u043f\u0440\u043e\u0441\u044b \u0432 \u0440\u0435\u0430\u043b\u044c\u043d\u043e\u043c \u0432\u0440\u0435\u043c\u0435\u043d\u0438. \u041e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u0441\u043c\u0435\u0449\u0435\u043d\u0438\u044f (offset)\n    \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0430\u0435\u0442 \u043f\u043e\u043b\u0443\u0447\u0435\u043d\u0438\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u043d\u043e\u0432\u044b\u0445 \u043e\u0431\u043d\u043e\u0432\u043b\u0435\u043d\u0438\u0439, \u0438\u0437\u0431\u0435\u0433\u0430\u044f \u0434\u0443\u0431\u043b\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f. \u0422\u0430\u0439\u043c\u0430\u0443\u0442 \u0438 \u043e\u0431\u0440\u0430\u0431\u043e\u0442\u043a\u0430 \u043e\u0448\u0438\u0431\u043e\u043a \u0433\u0430\u0440\u0430\u043d\u0442\u0438\u0440\u0443\u044e\u0442\n    \u0441\u0442\u0430\u0431\u0438\u043b\u044c\u043d\u0443\u044e \u0440\u0430\u0431\u043e\u0442\u0443 \u043f\u0440\u0438 \u0441\u0435\u0442\u0435\u0432\u044b\u0445 \u0441\u0431\u043e\u044f\u0445 \u0438\u043b\u0438 \u0432\u0440\u0435\u043c\u0435\u043d\u043d\u043e\u0439 \u043d\u0435\u0434\u043e\u0441\u0442\u0443\u043f\u043d\u043e\u0441\u0442\u0438 API.\n    \"\"\"\n    url: str = build_api_url(\"getUpdates\")\n    params: Dict[str, Any] = {\"timeout\": timeout}\n\n    if offset is not None:\n        params[\"offset\"] = offset\n\n    try:\n        client_timeout = aiohttp.ClientTimeout(\n            total=timeout + ADDITIONAL_WAIT_TIME\n        )\n        async with session.get(url, params=params,\n                               timeout=client_timeout) as response:\n            if response.status != SUCCESS_CODE:\n                print(f\"HTTP error in get_updates: {response.status}\")\n                return {\"ok\": False, \"result\": []}\n\n            result: Dict[str, Any] = await response.json()\n            return result\n\n    except aiohttp.ClientError as e:\n        print(f\"Request failed in get_updates: {e}\")\n        return {\"ok\": False, \"result\": []}\n\n    except asyncio.TimeoutError:\n        print(\"Timeout in get_updates, retrying later...\")\n        return {\"ok\": False, \"result\": []}\n</code></pre>"},{"location":"lab4/async_bot/#lab4.async_bot.get_weather_for_city","title":"<code>get_weather_for_city(session, city)</code>  <code>async</code>","text":"<p>Asynchronously fetches weather data for a specified city using the OpenWeatherMap API.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>ClientSession</code> <p>The aiohttp client session for making HTTP requests.</p> required <code>city</code> <code>str</code> <p>The name of the city to get weather data for.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A formatted string containing weather information including temperature, feels-like temperature, and weather description in Russian. Returns an error message if the request fails or city is not found.</p> <p>This method provides real-time weather updates to support notification services that require current environmental data for user interactions.</p> Source code in <code>lab4/async_bot.py</code> <pre><code>async def get_weather_for_city(session: aiohttp.ClientSession,\n                               city: str) -&gt; str:\n    \"\"\"\n    Asynchronously fetches weather data for a specified city using the OpenWeatherMap API.\n\n    Args:\n        session (aiohttp.ClientSession): The aiohttp client session for making HTTP requests.\n        city (str): The name of the city to get weather data for.\n\n    Returns:\n        str: A formatted string containing weather information including temperature, feels-like temperature, and weather description in Russian. Returns an error message if the request fails or city is not found.\n\n    Why:\n    This method provides real-time weather updates to support notification services that require current environmental data for user interactions.\n    \"\"\"\n    params = {\n        \"q\": city, \"appid\": OPENWEATHER_API_KEY,\n        \"units\": \"metric\", \"lang\": \"ru\",\n    }\n\n    try:\n        timeout = aiohttp.ClientTimeout(total=REQUEST_TIMEOUT)\n        async with session.get(OPENWEATHER_URL,\n                               params=params,\n                               timeout=timeout) as response:\n            if response.status != SUCCESS_CODE:\n                return (f\"Can't recieve weather for city {city}. \"\n                        f\"Code {response.status}\")\n\n            data: Dict[str, Any] = await response.json()\n\n    except aiohttp.ClientError as e:\n        return f\"Can't recieve weather {e}\"\n\n    if int(data.get(\"cod\", 0)) != SUCCESS_CODE:\n        message = data.get(\"message\", \"error\")\n        return f\"City {city}: doesn't exist {message}\"\n\n    main = data.get(\"main\", {})\n    weather_list = data.get(\"weather\", [])\n\n    temp = main.get(\"temp\")\n    feels_like = main.get(\"feels_like\")\n    description = weather_list[0].get(\"description\") if weather_list \\\n        else \"No description\"\n\n    return (\n        f\"\u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430 \u0432 {city}:\\n\"\n        f\"- {description}\\n\"\n        f\"- \u0422\u0435\u043c\u043f\u0435\u0440\u0430\u0442\u0443\u0440\u0430: {temp}\\n\"\n        f\"- \u041e\u0449\u0443\u0449\u0430\u0435\u0442\u0441\u044f \u043a\u0430\u043a: {feels_like}\\n\"\n    )\n</code></pre>"},{"location":"lab4/async_bot/#lab4.async_bot.main","title":"<code>main()</code>  <code>async</code>","text":"<p>Main event loop for an asynchronous Telegram echo bot that handles multiple command types and background monitoring.</p> <p>The bot continuously polls for Telegram updates and processes incoming messages to provide various services including weather information, daily quotes, news headlines, and subscription management. It also runs a background task for monitoring external data sources and sending notifications.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>The method implements the core message processing logic to handle user interactions and maintain real-time communication with Telegram users. It processes different command types to provide requested information services while simultaneously running background monitoring tasks to deliver proactive notifications. The asynchronous design allows concurrent handling of message processing and background monitoring for efficient resource utilization and responsive user experience.</p> Source code in <code>lab4/async_bot.py</code> <pre><code>async def main() -&gt; None:\n    \"\"\"\n    Main event loop for an asynchronous Telegram echo bot that handles multiple command types and background monitoring.\n\n    The bot continuously polls for Telegram updates and processes incoming messages to provide various services\n    including weather information, daily quotes, news headlines, and subscription management. It also runs a background\n    task for monitoring external data sources and sending notifications.\n\n    Args:\n        None\n\n    Returns:\n        None\n\n    Why:\n    The method implements the core message processing logic to handle user interactions and maintain real-time\n    communication with Telegram users. It processes different command types to provide requested information\n    services while simultaneously running background monitoring tasks to deliver proactive notifications.\n    The asynchronous design allows concurrent handling of message processing and background monitoring\n    for efficient resource utilization and responsive user experience.\n    \"\"\"\n    offset: Optional[int] = None\n    print(\"Async echo bot started\")\n\n    async with aiohttp.ClientSession() as session:\n        bars_task = asyncio.create_task(\n            poll_bars_and_notify(session, send_message,\n                                 previous_state, interval=BARS_POLL_INTERVAL)\n        )\n        try:\n            while True:\n                result = await get_updates(session, offset=offset)\n\n                if not result.get(\"ok\"):\n                    print(f\"Error getting updates: {result}\")\n                    await asyncio.sleep(SLEEP_TIME)\n                    continue\n\n                updates: List[Dict[str, Any]] = result.get(\"result\", [])\n\n                for update in updates:\n                    message = update.get(\"message\")\n                    if message is None:\n                        continue\n\n                    chat_id = message.get(\"chat\", {}).get(\"id\")\n                    text = message.get(\"text\")\n                    user_id = message.get(\"from\", {}).get(\"id\")\n\n                    if chat_id is None or text is None or user_id is None:\n                        continue\n\n                    print(f\"Received from {chat_id}: {text}\")\n\n                    state = user_states.get(user_id)\n\n                    if state == \"waiting_for_city\":\n                        city_name = text.strip()\n                        weather_text = await\\\n                            get_weather_for_city(session, city_name)\n                        await send_message(session, chat_id, weather_text)\n                        del user_states[user_id]\n\n                    elif text == \"/weather\":\n                        user_states[user_id] = \"waiting_for_city\"\n                        await send_message(session, chat_id,\n                                           \"\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0433\u043e\u0440\u043e\u0434\u0430..\")\n\n                    elif text == \"/quote\":\n                        # \u0432\u044b\u043d\u043e\u0441\u0438\u043c \u0432 \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u044b\u0439 \u043f\u043e\u0442\u043e\u043a \u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u0443\u044e \u0444\u0443\u043d\u043a\u0446\u0438\u044e\n                        quote = await asyncio.to_thread(get_daily_quote)\n                        await send_message(session, chat_id, quote)\n                    elif text == \"/headlines\":\n                        headlines = await get_headlines(session)\n                        await send_message(session, chat_id, headlines)\n\n                    elif text.startswith(\"/set_isu \"):\n                        isu = text[len(\"/set_isu \"):].strip()\n                        if add_subscription(isu, chat_id):\n                            await send_message(session, chat_id,\n                                               f\"\u0418\u0421\u0423 {isu} \u0441\u043e\u0445\u0440\u0430\u043d\u0451\u043d\")\n                        else:\n                            await send_message(session, chat_id,\n                                               \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0438\")\n\n                    elif text.startswith(\"/set_fio \"):\n                        fio = text[len(\"/set_fio \"):].strip()\n                        if add_subscription(fio.lower(), chat_id):\n                            await send_message(session, chat_id,\n                                               f\"\u0424\u0418\u041e '{fio}' \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u043e\")\n                        else:\n                            await send_message(session, chat_id,\n                                               \"\u041e\u0448\u0438\u0431\u043a\u0430 \u043f\u0440\u0438 \u0441\u043e\u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0438\")\n                    else:\n                        await send_message(session, chat_id, text)\n\n                    update_id = update.get(\"update_id\")\n                    if update_id is not None:\n                        offset = update_id + 1\n\n        except KeyboardInterrupt:\n            bars_task.cancel()\n            print(\"\\nAsync bot stopped\")\n</code></pre>"},{"location":"lab4/async_bot/#lab4.async_bot.send_message","title":"<code>send_message(session, chat_id, text)</code>  <code>async</code>","text":"<p>\u0410\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0432 Telegram \u0447\u0430\u0442.</p> <p>\u041e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0432 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0447\u0430\u0442 \u0447\u0435\u0440\u0435\u0437 Telegram Bot API. \u041c\u0435\u0442\u043e\u0434 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0435 \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u0438 \u043e\u0448\u0438\u0431\u043e\u043a, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u0441\u0435\u0442\u0435\u0432\u044b\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b \u0438 \u043e\u0448\u0438\u0431\u043a\u0438 API, \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u044f \u043d\u0430\u0434\u0435\u0436\u043d\u0443\u044e \u0434\u043e\u0441\u0442\u0430\u0432\u043a\u0443 \u0443\u0432\u0435\u0434\u043e\u043c\u043b\u0435\u043d\u0438\u0439.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>ClientSession</code> <p>\u0410\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u0430\u044f HTTP-\u0441\u0435\u0441\u0441\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430</p> required <code>chat_id</code> <code>int</code> <p>\u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0447\u0430\u0442\u0430, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435</p> required <code>text</code> <code>str</code> <p>\u0422\u0435\u043a\u0441\u0442 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True \u0435\u0441\u043b\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e, False \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043e\u0448\u0438\u0431\u043a\u0438</p> Source code in <code>lab4/async_bot.py</code> <pre><code>async def send_message(session: aiohttp.ClientSession,\n                       chat_id: int, text: str) -&gt; bool:\n    \"\"\"\n    \u0410\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0432 Telegram \u0447\u0430\u0442.\n\n    \u041e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442 \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u043e\u0435 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0432 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0447\u0430\u0442 \u0447\u0435\u0440\u0435\u0437 Telegram Bot API.\n    \u041c\u0435\u0442\u043e\u0434 \u043e\u0431\u0440\u0430\u0431\u0430\u0442\u044b\u0432\u0430\u0435\u0442 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u044b\u0435 \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u0438 \u043e\u0448\u0438\u0431\u043e\u043a, \u0432\u043a\u043b\u044e\u0447\u0430\u044f \u0441\u0435\u0442\u0435\u0432\u044b\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u044b\n    \u0438 \u043e\u0448\u0438\u0431\u043a\u0438 API, \u043e\u0431\u0435\u0441\u043f\u0435\u0447\u0438\u0432\u0430\u044f \u043d\u0430\u0434\u0435\u0436\u043d\u0443\u044e \u0434\u043e\u0441\u0442\u0430\u0432\u043a\u0443 \u0443\u0432\u0435\u0434\u043e\u043c\u043b\u0435\u043d\u0438\u0439.\n\n    Args:\n        session (aiohttp.ClientSession): \u0410\u0441\u0438\u043d\u0445\u0440\u043e\u043d\u043d\u0430\u044f HTTP-\u0441\u0435\u0441\u0441\u0438\u044f \u0434\u043b\u044f \u0432\u044b\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f \u0437\u0430\u043f\u0440\u043e\u0441\u0430\n        chat_id (int): \u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0447\u0430\u0442\u0430, \u0432 \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u044f\u0435\u0442\u0441\u044f \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435\n        text (str): \u0422\u0435\u043a\u0441\u0442 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u044f \u0434\u043b\u044f \u043e\u0442\u043f\u0440\u0430\u0432\u043a\u0438\n\n    Returns:\n        bool: True \u0435\u0441\u043b\u0438 \u0441\u043e\u043e\u0431\u0449\u0435\u043d\u0438\u0435 \u0443\u0441\u043f\u0435\u0448\u043d\u043e \u043e\u0442\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043e, False \u0432 \u0441\u043b\u0443\u0447\u0430\u0435 \u043e\u0448\u0438\u0431\u043a\u0438\n    \"\"\"\n    url: str = build_api_url(\"sendMessage\")\n    payload: Dict[str, Any] = {\"chat_id\": chat_id, \"text\": text}\n\n    try:\n        timeout = aiohttp.ClientTimeout(total=REQUEST_TIMEOUT)\n        async with (session.post(url, json=payload, timeout=timeout)\n                    as response):\n            if response.status != SUCCESS_CODE:\n                print(f\"HTTP error in send_message: {response.status}\")\n                return False\n\n            result: Dict[str, Any] = await response.json()\n\n        if result.get(\"ok\"):\n            print(f\"Message sent to {chat_id}\")\n            return True\n\n        print(f\"Message failed to send to {chat_id}: \"\n              f\"{result.get('description')}\")\n        return False\n\n    except aiohttp.ClientError as e:\n        print(f\"Request failed in send_message: {e}\")\n        return False\n</code></pre>"},{"location":"lab4/bars_db/","title":"Bars Db","text":""},{"location":"lab4/bars_db/#lab4.bars_db.add_subscription","title":"<code>add_subscription(identifier, chat_id)</code>","text":"<p>Add a subscription mapping an identifier to a chat_id.</p> <p>This method ensures that a specific identifier (which could represent a user or entity)  is associated with a Telegram chat ID in the database. If an existing subscription  for the identifier already exists, it will be replaced with the new chat_id.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>The identifier (e.g., user ID or name) to subscribe.</p> required <code>chat_id</code> <code>int</code> <p>The Telegram chat ID to associate with the identifier.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the subscription was successfully added or updated, False otherwise.</p> Source code in <code>lab4/bars_db.py</code> <pre><code>def add_subscription(identifier: str, chat_id: int) -&gt; bool:\n    \"\"\"\n    Add a subscription mapping an identifier to a chat_id.\n\n    This method ensures that a specific identifier (which could represent a user or entity) \n    is associated with a Telegram chat ID in the database. If an existing subscription \n    for the identifier already exists, it will be replaced with the new chat_id.\n\n    Args:\n        identifier (str): The identifier (e.g., user ID or name) to subscribe.\n        chat_id (int): The Telegram chat ID to associate with the identifier.\n\n    Returns:\n        bool: True if the subscription was successfully added or updated, False otherwise.\n    \"\"\"\n    try:\n        conn = sqlite3.connect(DATABASE_FILE)\n        cursor = conn.cursor()\n        cursor.execute(\n            \"INSERT OR REPLACE INTO subscriptions \"\n            \"(identifier, chat_id) VALUES (?, ?)\",\n            (identifier, chat_id),\n        )\n        conn.commit()\n        conn.close()\n        return True\n    except Exception as e:\n        print(f\"Error adding subscription: {e}\")\n        return False\n</code></pre>"},{"location":"lab4/bars_db/#lab4.bars_db.get_all_subscriptions","title":"<code>get_all_subscriptions()</code>","text":"<p>Retrieve all active subscriptions from the database as a mapping of identifiers to chat IDs.</p> <p>This method provides a complete view of currently subscribed users and their associated chat identifiers, enabling the system to efficiently route notifications and updates to the appropriate Telegram chats.</p> <p>Returns:</p> Type Description <code>Dict[str, int]</code> <p>Dict[str, int]: A dictionary where keys are unique identifiers and values are Telegram chat IDs.            Returns an empty dictionary if an error occurs or no subscriptions exist.</p> Source code in <code>lab4/bars_db.py</code> <pre><code>def get_all_subscriptions() -&gt; Dict[str, int]:\n    \"\"\"\n    Retrieve all active subscriptions from the database as a mapping of identifiers to chat IDs.\n\n    This method provides a complete view of currently subscribed users and their associated chat identifiers,\n    enabling the system to efficiently route notifications and updates to the appropriate Telegram chats.\n\n    Args:\n        None\n\n    Returns:\n        Dict[str, int]: A dictionary where keys are unique identifiers and values are Telegram chat IDs.\n                       Returns an empty dictionary if an error occurs or no subscriptions exist.\n    \"\"\"\n    try:\n        conn = sqlite3.connect(DATABASE_FILE)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT identifier, chat_id FROM subscriptions\")\n        rows = cursor.fetchall()\n        conn.close()\n        return {row[0]: row[1] for row in rows}\n    except Exception as e:\n        print(f\"Error getting subscriptions: {e}\")\n        return {}\n</code></pre>"},{"location":"lab4/bars_db/#lab4.bars_db.get_chat_id","title":"<code>get_chat_id(identifier)</code>","text":"<p>Retrieve the chat_id associated with a given identifier from the database.</p> <p>This method enables the bot to look up the Telegram chat ID for a specific user or entity identifier, which is essential for directing notifications and updates to the correct recipient.</p> <p>Parameters:</p> Name Type Description Default <code>identifier</code> <code>str</code> <p>The unique identifier (e.g., ISU number or full name) used to look up the chat_id.</p> required <p>Returns:</p> Type Description <code>Optional[int]</code> <p>Optional[int]: The chat_id if found, otherwise None if no matching record exists or an error occurs.</p> Source code in <code>lab4/bars_db.py</code> <pre><code>def get_chat_id(identifier: str) -&gt; Optional[int]:\n    \"\"\"\n    Retrieve the chat_id associated with a given identifier from the database.\n\n    This method enables the bot to look up the Telegram chat ID for a specific user or entity identifier, which is essential for directing notifications and updates to the correct recipient.\n\n    Args:\n        identifier (str): The unique identifier (e.g., ISU number or full name) used to look up the chat_id.\n\n    Returns:\n        Optional[int]: The chat_id if found, otherwise None if no matching record exists or an error occurs.\n    \"\"\"\n    try:\n        conn = sqlite3.connect(DATABASE_FILE)\n        cursor = conn.cursor()\n        cursor.execute(\n            \"SELECT chat_id FROM subscriptions WHERE identifier = ?\",\n            (identifier,))\n        row = cursor.fetchone()\n        conn.close()\n        return row[0] if row else None\n    except Exception as e:\n        print(f\"Error getting chat_id: {e}\")\n        return None\n</code></pre>"},{"location":"lab4/bars_db/#lab4.bars_db.init_db","title":"<code>init_db()</code>","text":"<p>Initialize the database by creating necessary tables if they don't exist.</p> <p>This method ensures the database schema is properly set up to support  the bot's notification and tracking functionality. It creates tables  for managing user subscriptions and maintaining change history for  debugging and monitoring purposes.</p> <p>Args: None</p> <p>Returns: None</p> Source code in <code>lab4/bars_db.py</code> <pre><code>def init_db() -&gt; None:\n    \"\"\"\n    Initialize the database by creating necessary tables if they don't exist.\n\n    This method ensures the database schema is properly set up to support \n    the bot's notification and tracking functionality. It creates tables \n    for managing user subscriptions and maintaining change history for \n    debugging and monitoring purposes.\n\n    Args: None\n\n    Returns: None\n    \"\"\"\n    conn = sqlite3.connect(DATABASE_FILE)\n    cursor = conn.cursor()\n\n    # \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u043f\u043e\u0434\u043f\u0438\u0441\u043e\u043a: \u0418\u0421\u0423/\u0424\u0418\u041e -&gt; chat_id\n    cursor.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS subscriptions (\n            id INTEGER PRIMARY KEY,\n            identifier TEXT UNIQUE NOT NULL,\n            chat_id INTEGER NOT NULL,\n            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        )\n    \"\"\")\n\n    # \u0422\u0430\u0431\u043b\u0438\u0446\u0430 \u0438\u0441\u0442\u043e\u0440\u0438\u0438 \u0438\u0437\u043c\u0435\u043d\u0435\u043d\u0438\u0439 (\u043e\u043f\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e, \u0434\u043b\u044f \u043e\u0442\u043b\u0430\u0434\u043a\u0438)\n    cursor.execute(\"\"\"\n        CREATE TABLE IF NOT EXISTS change_history (\n            id INTEGER PRIMARY KEY,\n            table_id TEXT NOT NULL,\n            identifier TEXT NOT NULL,\n            column_name TEXT NOT NULL,\n            old_value TEXT,\n            new_value TEXT,\n            changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n        )\n    \"\"\")\n\n    conn.commit()\n    conn.close()\n</code></pre>"},{"location":"lab4/bars_db/#lab4.bars_db.log_change","title":"<code>log_change(table_id, identifier, column_name, old_value, new_value)</code>","text":"<p>Logs a change to the database for tracking and debugging purposes.</p> <p>This method records changes made to specific columns in database tables, creating an audit trail that can be used for debugging, monitoring data modifications, and maintaining data integrity.</p> <p>Parameters:</p> Name Type Description Default <code>table_id</code> <code>str</code> <p>The identifier of the table where the change occurred</p> required <code>identifier</code> <code>str</code> <p>The unique identifier of the record that was modified</p> required <code>column_name</code> <code>str</code> <p>The name of the column that was changed</p> required <code>old_value</code> <code>str</code> <p>The previous value of the column before modification</p> required <code>new_value</code> <code>str</code> <p>The new value of the column after modification</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>lab4/bars_db.py</code> <pre><code>def log_change(\n        table_id: str,\n        identifier: str,\n        column_name: str,\n        old_value: str,\n        new_value: str) -&gt; None:\n    \"\"\"\n    Logs a change to the database for tracking and debugging purposes.\n\n    This method records changes made to specific columns in database tables,\n    creating an audit trail that can be used for debugging, monitoring data modifications,\n    and maintaining data integrity.\n\n    Args:\n        table_id: The identifier of the table where the change occurred\n        identifier: The unique identifier of the record that was modified\n        column_name: The name of the column that was changed\n        old_value: The previous value of the column before modification\n        new_value: The new value of the column after modification\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        conn = sqlite3.connect(DATABASE_FILE)\n        cursor = conn.cursor()\n        cursor.execute(\n            \"\"\"INSERT INTO change_history\n               (table_id, identifier, column_name, old_value, new_value)\n               VALUES (?, ?, ?, ?, ?)\"\"\",\n            (table_id, identifier, column_name, old_value, new_value),\n        )\n        conn.commit()\n        conn.close()\n    except Exception as e:\n        print(f\"Error logging change: {e}\")\n</code></pre>"},{"location":"lab4/bars_watcher/","title":"Bars Watcher","text":""},{"location":"lab4/bars_watcher/#lab4.bars_watcher.poll_bars_and_notify","title":"<code>poll_bars_and_notify(session, send_func, state, interval=BARS_POLL_INTERVAL)</code>  <code>async</code>","text":"<p>Periodically monitors configured data sources for changes and sends notifications when updates are detected.</p> <p>This method continuously polls multiple data tables to detect modifications compared to the previous state. It maintains real-time synchronization between the data sources and notification system to ensure subscribers receive timely updates.</p> <p>Parameters:</p> Name Type Description Default <code>session</code> <code>ClientSession</code> <p>HTTP client session for making API requests</p> required <code>send_func</code> <p>Function responsible for delivering notifications</p> required <code>state</code> <code>PreviousState</code> <p>Object storing previous state data for change detection</p> required <code>interval</code> <code>int</code> <p>Polling interval in seconds (default: BARS_POLL_INTERVAL)</p> <code>BARS_POLL_INTERVAL</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>lab4/bars_watcher.py</code> <pre><code>async def poll_bars_and_notify(\n        session: aiohttp.ClientSession,\n        send_func,\n        state: PreviousState,\n        interval: int = BARS_POLL_INTERVAL) -&gt; None:\n    \"\"\"\n    Periodically monitors configured data sources for changes and sends notifications when updates are detected.\n\n    This method continuously polls multiple data tables to detect modifications compared to the previous state. It maintains real-time synchronization between the data sources and notification system to ensure subscribers receive timely updates.\n\n    Args:\n        session: HTTP client session for making API requests\n        send_func: Function responsible for delivering notifications\n        state: Object storing previous state data for change detection\n        interval: Polling interval in seconds (default: BARS_POLL_INTERVAL)\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        init_db()\n        print(\"\u0411\u0414 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0438\u0440\u043e\u0432\u0430\u043d\u0430\")\n    except Exception as e:\n        print(f\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0438\u043d\u0438\u0446\u0438\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u0438 \u0411\u0414: {e}\")\n        return\n\n    print(f\"BARS watcher \u0437\u0430\u043f\u0443\u0449\u0435\u043d (\u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b: {interval}s)\")\n\n    while True:\n        try:\n            subscriptions = get_all_subscriptions()\n\n            # \u0441\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u0442\u0430\u0441\u043a\u043e\u0432 \u0434\u043e \u0438\u0445 \u043e\u0436\u0438\u0434\u0430\u043d\u0438\u044f\n            tasks = [\n                _check_sheet(cfg, session, send_func, subscriptions, state)\n                for cfg in BARS_SHEETS]\n\n            await asyncio.gather(*tasks, return_exceptions=True)\n\n            await asyncio.sleep(interval)\n\n        except Exception as e:\n            print(f\"\u041e\u0448\u0438\u0431\u043a\u0430 \u0432 poll_bars_and_notify: {e}\")\n            await asyncio.sleep(ADDITIONAL_WAIT_TIME)\n</code></pre>"},{"location":"lab4/constants/","title":"Constants","text":""},{"location":"lab4/constants/#lab4.constants.BarsSheetConfig","title":"<code>BarsSheetConfig</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>A configuration class for specifying spreadsheet settings for bar data extraction.</p> <pre><code>Class Attributes:\n- table_id: Identifier for the specific table within the spreadsheet.\n- spreadsheet_id: Unique identifier for the Google Sheets spreadsheet.\n- sheet_name: Name of the specific sheet within the spreadsheet.\n- header_rows: Number of header rows to skip before data begins.\n- columns_to_scan: Range of columns to extract data from.\n\nThis class provides the necessary configuration parameters to locate and extract\nbar data from a Google Sheets document, including spreadsheet identification,\nsheet selection, and data range specifications.\n</code></pre> Source code in <code>lab4/constants.py</code> <pre><code>class BarsSheetConfig(TypedDict):\n    \"\"\"\n    A configuration class for specifying spreadsheet settings for bar data extraction.\n\n        Class Attributes:\n        - table_id: Identifier for the specific table within the spreadsheet.\n        - spreadsheet_id: Unique identifier for the Google Sheets spreadsheet.\n        - sheet_name: Name of the specific sheet within the spreadsheet.\n        - header_rows: Number of header rows to skip before data begins.\n        - columns_to_scan: Range of columns to extract data from.\n\n        This class provides the necessary configuration parameters to locate and extract\n        bar data from a Google Sheets document, including spreadsheet identification,\n        sheet selection, and data range specifications.\n    \"\"\"\n\n    table_id: str  # \u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u0442\u0430\u0431\u043b\u0438\u0446\u044b\n    spreadsheet_id: str  # Google Sheets ID\n    sheet_name: str  # \u0438\u043c\u044f \u043b\u0438\u0441\u0442\u0430\n    header_rows: int  # \u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0432\u0435\u0440\u0445\u043d\u0438\u0445 \u0441\u0442\u0440\u043e\u043a \u2014 \u0437\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a\n    columns_to_scan: int  # \u0432 \u0441\u043a\u043e\u043b\u044c\u043a\u0438\u0445 \u043f\u0435\u0440\u0432\u044b\u0445 \u0441\u0442\u043e\u043b\u0431\u0446\u0430\u0445 \u0438\u0441\u043a\u0430\u0442\u044c \u0418\u0421\u0423/\u0424\u0418\u041e\n</code></pre>"},{"location":"lab4/google_sheets_client/","title":"Google Sheets Client","text":""},{"location":"lab4/google_sheets_client/#lab4.google_sheets_client.find_identifier_in_row","title":"<code>find_identifier_in_row(row, columns_to_scan=50)</code>","text":"<p>Searches for the first non-empty value in the first N columns of a row.</p> <p>This function is used to extract meaningful data from spreadsheet rows by skipping empty cells and returning the first available value. It helps identify rows that contain actual data entries rather than blank or placeholder values.</p> <p>Parameters:</p> Name Type Description Default <code>row</code> <code>List[str]</code> <p>A list of strings representing a row from a spreadsheet or tabular data.</p> required <code>columns_to_scan</code> <code>int</code> <p>The maximum number of columns to check from the beginning of the row.             Defaults to 50 columns.</p> <code>50</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The first non-empty string value found in the specified columns, or None if </p> <code>Optional[str]</code> <p>all scanned columns are empty.</p> Source code in <code>lab4/google_sheets_client.py</code> <pre><code>def find_identifier_in_row(row: List[str],\n                           columns_to_scan: int = 50) -&gt; Optional[str]:\n    \"\"\"\n    Searches for the first non-empty value in the first N columns of a row.\n\n    This function is used to extract meaningful data from spreadsheet rows by skipping\n    empty cells and returning the first available value. It helps identify rows that\n    contain actual data entries rather than blank or placeholder values.\n\n    Args:\n        row: A list of strings representing a row from a spreadsheet or tabular data.\n        columns_to_scan: The maximum number of columns to check from the beginning of the row.\n                        Defaults to 50 columns.\n\n    Returns:\n        The first non-empty string value found in the specified columns, or None if \n        all scanned columns are empty.\n    \"\"\"\n    for col_idx in range(min(columns_to_scan, len(row))):\n        val = row[col_idx].strip()\n        if val:\n            return val\n    return None\n</code></pre>"},{"location":"lab4/google_sheets_client/#lab4.google_sheets_client.get_column_headers","title":"<code>get_column_headers(config)</code>","text":"<p>Extract column headers from the first row of a spreadsheet.</p> <p>This method retrieves column headers to establish a mapping between column indices and their corresponding names, enabling structured access to spreadsheet data. It implements caching to optimize performance by avoiding repeated API calls for the same spreadsheet.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BarsSheetConfig</code> <p>Configuration object containing spreadsheet_id and sheet_name identifiers.</p> required <p>Returns:</p> Type Description <code>Dict[int, str]</code> <p>Dictionary mapping column indices (int) to header names (str).</p> Source code in <code>lab4/google_sheets_client.py</code> <pre><code>def get_column_headers(config: BarsSheetConfig) -&gt; Dict[int, str]:\n    \"\"\"\n    Extract column headers from the first row of a spreadsheet.\n\n    This method retrieves column headers to establish a mapping between column indices and their corresponding names, enabling structured access to spreadsheet data. It implements caching to optimize performance by avoiding repeated API calls for the same spreadsheet.\n\n    Args:\n        config: Configuration object containing spreadsheet_id and sheet_name identifiers.\n\n    Returns:\n        Dictionary mapping column indices (int) to header names (str).\n    \"\"\"\n    cache_key = (config[\"spreadsheet_id\"], config[\"sheet_name\"])\n\n    if cache_key in _headers_cache:\n        headers = _headers_cache[cache_key]\n    else:\n        rows = get_sheet_rows(config)\n        if rows is None or len(rows) == 0:\n            return {}\n\n        headers = rows[0]\n        _headers_cache[cache_key] = headers\n\n    return {idx: name for idx, name in enumerate(headers)}\n</code></pre>"},{"location":"lab4/google_sheets_client/#lab4.google_sheets_client.get_sheet_rows","title":"<code>get_sheet_rows(config)</code>","text":"<p>Retrieve all rows from a Google Sheets worksheet.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>BarsSheetConfig</code> <p>Configuration object containing spreadsheet ID and worksheet name.</p> required <p>Returns:</p> Type Description <code>Optional[List[List[str]]]</code> <p>List of lists containing all worksheet values if successful, None if an error occurs.</p> <p>This method handles authentication and API interactions with Google Sheets to fetch complete worksheet data. It returns None on errors to allow calling code to handle failures gracefully rather than raising exceptions.</p> Source code in <code>lab4/google_sheets_client.py</code> <pre><code>def get_sheet_rows(config: BarsSheetConfig) -&gt; Optional[List[List[str]]]:\n    \"\"\"\n    Retrieve all rows from a Google Sheets worksheet.\n\n    Args:\n        config: Configuration object containing spreadsheet ID and worksheet name.\n\n    Returns:\n        List of lists containing all worksheet values if successful, None if an error occurs.\n\n    This method handles authentication and API interactions with Google Sheets to fetch\n    complete worksheet data. It returns None on errors to allow calling code to handle\n    failures gracefully rather than raising exceptions.\n    \"\"\"\n    try:\n        creds = Credentials.from_service_account_file(\n            GOOGLE_SHEETS_CREDENTIALS_FILE,\n            scopes=_SCOPES,\n        )\n        client = gspread.authorize(creds)\n        spreadsheet = client.open_by_key(config[\"spreadsheet_id\"])\n        sheet = spreadsheet.worksheet(config[\"sheet_name\"])\n\n        return sheet.get_all_values()\n\n    except Exception as e:\n        print(f\"Error reading sheet {config['table_id']}: {e}\")\n        return None\n</code></pre>"},{"location":"lab4/sync_bot/","title":"Sync Bot","text":""},{"location":"lab4/sync_bot/#lab4.sync_bot.build_api_url","title":"<code>build_api_url(method_name)</code>","text":"<p>Builds a complete API URL for making Telegram Bot API requests.</p> <p>This method constructs the full endpoint URL by combining the base API URL,  bot token, and specific method name to form a valid Telegram Bot API call.</p> <p>Parameters:</p> Name Type Description Default <code>method_name</code> <code>str</code> <p>Name of the Telegram Bot API method (e.g., 'getMe', 'sendMessage')</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Complete URL string ready for HTTP requests to the Telegram API</p> Source code in <code>lab4/sync_bot.py</code> <pre><code>def build_api_url(method_name: str) -&gt; str:\n    \"\"\"\n    Builds a complete API URL for making Telegram Bot API requests.\n\n    This method constructs the full endpoint URL by combining the base API URL, \n    bot token, and specific method name to form a valid Telegram Bot API call.\n\n    Args:\n        method_name: Name of the Telegram Bot API method (e.g., 'getMe', 'sendMessage')\n\n    Returns:\n        str: Complete URL string ready for HTTP requests to the Telegram API\n    \"\"\"\n    return f\"{API_BASE_URL}{BOT_TOKEN}/{method_name}\"\n</code></pre>"},{"location":"lab4/sync_bot/#lab4.sync_bot.check_token","title":"<code>check_token()</code>","text":"<p>Validates the bot's authentication token by testing API connectivity and displays bot information.</p> <p>This method performs a health check of the bot's API connection by making a test request to verify the token is valid and retrieve basic bot details. It ensures the bot is properly configured before proceeding with other operations.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RequestException</code> <p>If the API request fails due to network issues or invalid response.</p> Source code in <code>lab4/sync_bot.py</code> <pre><code>def check_token() -&gt; None:\n    \"\"\"\n    Validates the bot's authentication token by testing API connectivity and displays bot information.\n\n    This method performs a health check of the bot's API connection by making a test request\n    to verify the token is valid and retrieve basic bot details. It ensures the bot is properly\n    configured before proceeding with other operations.\n\n    Args:\n        None\n\n    Returns:\n        None\n\n    Raises:\n        requests.exceptions.RequestException: If the API request fails due to network issues\n            or invalid response.\n    \"\"\"\n    url: str = build_api_url(\"getMe\")\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()  # \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 \u043d\u0430 \u0441\u0442\u0430\u0442\u0443\u0441 2xx\n        bot_info: Dict[str, Any] = response.json()  # json -&gt; dict\n\n        if bot_info.get(\"ok\"):\n            # get \u0431\u0435\u0437\u043e\u043f\u0430\u0441\u043d\u0435\u0435 bot_info[\"result\"] \u0442.\u043a. \u043d\u0435 \u0432\u044b\u0431\u0440\u0430\u0441\u044b\u0432\u0430\u0435\u0442 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u044f\n            result = bot_info.get(\"result\", {})\n            print(\"Bot is working!\")\n            print(f\"Bot ID: {result.get('id')}\")\n            print(f\"Bot username: {result.get('username')}\")\n            print(f\"Bot first name: {result.get('first_name')}\")\n        else:\n            print(f\"Error: {bot_info.get('description')}\")\n    except requests.exceptions.RequestException as e:\n        print(f\"Request failed: {e}\")\n</code></pre>"},{"location":"lab4/sync_bot/#lab4.sync_bot.get_daily_quote","title":"<code>get_daily_quote()</code>","text":"<p>Fetches the daily quote from quotes.toscrape.com.</p> <p>This method retrieves inspirational content to provide users with engaging and thought-provoking messages as part of the bot's information services.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The formatted quote text with author name, or an error message if the request fails.</p> Source code in <code>lab4/sync_bot.py</code> <pre><code>def get_daily_quote() -&gt; str:\n    \"\"\"\n    Fetches the daily quote from quotes.toscrape.com.\n\n    This method retrieves inspirational content to provide users with engaging and thought-provoking messages as part of the bot's information services.\n\n    Args:\n        None\n\n    Returns:\n        str: The formatted quote text with author name, or an error message if the request fails.\n\n    Raises:\n        None - exceptions are handled internally and returned as error messages.\n    \"\"\"\n    try:\n        response = requests.get(QUOTES_URL, timeout=REQUEST_TIMEOUT)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as e:\n        print(f\"Quote request failed: {e}\")\n        return \"I cant get a quote right now\"\n\n    soup = BeautifulSoup(response.text, \"html.parser\")\n\n    first_quote_block = soup.find(\"div\", class_=\"quote\")\n    if first_quote_block is None:\n        return \"No quote found\"\n\n    text_tag = first_quote_block.find(\"span\", class_=\"text\")\n    author_tag = first_quote_block.find(\"small\", class_=\"author\")\n\n    if text_tag is None or author_tag is None:\n        return \"Quote parse error\"\n\n    quote_text = text_tag.get_text(strip=True)\n    author_name = author_tag.get_text(strip=True)\n\n    return f'{quote_text} \u2014 {author_name}'\n</code></pre>"},{"location":"lab4/sync_bot/#lab4.sync_bot.get_updates","title":"<code>get_updates(offset=None, timeout=POLLING_TIMEOUT)</code>","text":"<p>Fetch updates from the Telegram Bot API.</p> <p>This method retrieves new messages and events from Telegram using long polling. It implements the getUpdates method to receive updates with optional offset for handling previously processed messages.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>Optional[int]</code> <p>The update_id to start fetching from (last processed update_id + 1). If None, retrieves all available updates.</p> <code>None</code> <code>timeout</code> <code>int</code> <p>Maximum time to wait for new updates in seconds.</p> <code>POLLING_TIMEOUT</code> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing API response with list of updates under 'result' key.</p> <code>Dict[str, Any]</code> <p>Returns {'ok': False, 'result': []} on request failure.</p> <p>Raises:</p> Type Description <code>RequestException</code> <p>If the HTTP request fails.</p> Source code in <code>lab4/sync_bot.py</code> <pre><code>def get_updates(offset: Optional[int] = None,\n                timeout: int = POLLING_TIMEOUT) -&gt; Dict[str, Any]:\n    \"\"\"\n    Fetch updates from the Telegram Bot API.\n\n    This method retrieves new messages and events from Telegram using long polling.\n    It implements the getUpdates method to receive updates with optional offset\n    for handling previously processed messages.\n\n    Args:\n        offset: The update_id to start fetching from (last processed update_id + 1).\n            If None, retrieves all available updates.\n        timeout: Maximum time to wait for new updates in seconds.\n\n    Returns:\n        Dictionary containing API response with list of updates under 'result' key.\n        Returns {'ok': False, 'result': []} on request failure.\n\n    Raises:\n        requests.exceptions.RequestException: If the HTTP request fails.\n    \"\"\"\n    url: str = build_api_url(\"getUpdates\")\n    params: Dict[str, Any] = {\"timeout\": timeout}\n\n    if offset is not None:\n        params[\"offset\"] = offset\n\n    try:\n        response = requests.get(url, params=params,\n                                timeout=timeout + ADDITIONAL_WAIT_TIME)\n        response.raise_for_status()\n        result: Dict[str, Any] = response.json()\n        return result\n    except requests.exceptions.RequestException as e:\n        print(f\"Request failed: {e}\")\n        return {\"ok\": False, \"result\": []}\n</code></pre>"},{"location":"lab4/sync_bot/#lab4.sync_bot.run_echo_bot","title":"<code>run_echo_bot()</code>","text":"<p>Starts an echo bot that listens for incoming messages and responds accordingly.</p> <p>The bot continuously polls for new messages and handles two types of responses: - For the '/quote' command, it fetches and sends a daily quote - For all other messages, it echoes back the received text</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>lab4/sync_bot.py</code> <pre><code>def run_echo_bot() -&gt; None:\n    \"\"\"\n    Starts an echo bot that listens for incoming messages and responds accordingly.\n\n    The bot continuously polls for new messages and handles two types of responses:\n    - For the '/quote' command, it fetches and sends a daily quote\n    - For all other messages, it echoes back the received text\n\n    Args:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    offset: Optional[int] = None\n    print(\"Echo bot started!\")\n\n    try:\n        while True:\n            result = get_updates(offset=offset)\n\n            if not result.get(\"ok\"):\n                print(f\"Error getting updates: {result}\")\n                time.sleep(SLEEP_TIME)\n                continue\n\n            updates: List[Dict[str, Any]] = result.get(\"result\", [])\n\n            for update in updates:\n                message_data = _extract_message_data(update)\n\n                if message_data is not None:\n                    chat_id = message_data[\"chat_id\"]\n                    text = message_data[\"text\"]\n\n                    print(f\"Recieved message from: {chat_id}, {text}\")\n\n                    if text == \"/quote\":\n                        quote = get_daily_quote()\n                        send_message(chat_id, quote)\n                    else:\n                        send_message(chat_id, text)\n\n                update_id = update.get(\"update_id\")\n                if update_id is not None:\n                    offset = update_id + 1\n\n    except KeyboardInterrupt:\n        print(\"\\nEcho bot stopped!\")\n</code></pre>"},{"location":"lab4/sync_bot/#lab4.sync_bot.send_message","title":"<code>send_message(chat_id, text)</code>","text":"<p>Send a message to a Telegram chat by chat_id.</p> <p>This method sends a POST request to the Telegram Bot API's sendMessage endpoint  to deliver text messages to specified chat recipients.</p> <p>Parameters:</p> Name Type Description Default <code>chat_id</code> <code>int</code> <p>Unique identifier for the target chat</p> required <code>text</code> <code>str</code> <p>Content of the message to be sent</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if message was successfully delivered, False if delivery failed</p> <p>Raises:</p> Type Description <code>RequestException</code> <p>If network request encounters an error</p> Source code in <code>lab4/sync_bot.py</code> <pre><code>def send_message(chat_id: int, text: str) -&gt; bool:\n    \"\"\"\n    Send a message to a Telegram chat by chat_id.\n\n    This method sends a POST request to the Telegram Bot API's sendMessage endpoint \n    to deliver text messages to specified chat recipients.\n\n    Args:\n        chat_id: Unique identifier for the target chat\n        text: Content of the message to be sent\n\n    Returns:\n        bool: True if message was successfully delivered, False if delivery failed\n\n    Raises:\n        requests.exceptions.RequestException: If network request encounters an error\n    \"\"\"\n    url: str = build_api_url(\"sendMessage\")\n    payload: Dict[str, Any] = {\"chat_id\": chat_id, \"text\": text}\n\n    try:\n        response = requests.post(url, json=payload, timeout=REQUEST_TIMEOUT)\n        response.raise_for_status()\n        result: Dict[str, Any] = response.json()\n\n        if result.get(\"ok\"):\n            print(f\"Message sent to {chat_id}\")\n            return True\n        else:\n            print(f\"Failed to send message to {chat_id}\"\n                  f\": {result.get('description')}\")\n            return False\n    except requests.exceptions.RequestException as e:\n        print(f\"Request failed: {e}\")\n        return False\n</code></pre>"}]}